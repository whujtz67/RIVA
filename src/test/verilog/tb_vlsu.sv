// ============================================================================
// tb_top.sv
// VLSU Testbench for cocotb integration
// ============================================================================

`timescale 1ns/1ps

// -----------------------------------------
// test bench generated by VERILUA
// -----------------------------------------
module tb_top import vlsu_pkg::*; import riva_pkg::*; (

`ifdef SIM_VERILATOR
  input wire clock,
  input wire reset
`endif // SIM_VERILATOR
);

  `include "axi/typedef.svh"

// -----------------------------------------
// macro define check
// -----------------------------------------
  `ifdef SIM_VERILATOR
    `ifdef SIM_VCS
      initial begin
        $error("Both SIM_VERILATOR and SIM_VCS are defined. Only one should be defined.");
        $finish;
      end
    `endif
  `else
    `ifndef SIM_VCS
      initial begin
        $error("Neither SIM_VERILATOR nor SIM_VCS is defined. One must be defined.");
        $finish;
      end
    `endif
  `endif

// -----------------------------------------
// Parameters for VLSU (following existing code patterns)
// -----------------------------------------
  // Core parameters (from VLSU.sv)
  localparam int unsigned NrLanes      = 4;
  localparam int unsigned VLEN         = 8192;
  localparam int unsigned ALEN         = 16384;

  typedef logic [$clog2(VLEN+1)-1:0] vlen_t;
  typedef logic [$clog2(ALEN+1)-1:0] alen_t;
  
  // AXI parameters (from VLSU.sv)
  localparam int unsigned AxiIdWidth   = 1;
  localparam int unsigned AxiDataWidth = 512;
  localparam int unsigned AxiAddrWidth = 32;
  localparam int unsigned AxiUserWidth = 1;

  typedef logic [DLEN/4-1:0] strb_t;
  
  // Type definitions following existing patterns
  typedef logic [AxiDataWidth  -1:0] axi_data_t;
  typedef logic [AxiDataWidth/8-1:0] axi_strb_t;
  typedef logic [AxiAddrWidth  -1:0] axi_addr_t;
  typedef logic [AxiUserWidth  -1:0] axi_user_t;
  typedef logic [AxiIdWidth    -1:0] axi_id_t;
  
  // AXI channel types (from axi_pkg)
  `AXI_TYPEDEF_AR_CHAN_T(ar_chan_t, axi_addr_t, axi_id_t  , axi_user_t)
  `AXI_TYPEDEF_R_CHAN_T (r_chan_t , axi_data_t, axi_id_t  , axi_user_t)
  `AXI_TYPEDEF_AW_CHAN_T(aw_chan_t, axi_addr_t, axi_id_t  , axi_user_t)
  `AXI_TYPEDEF_W_CHAN_T (w_chan_t , axi_data_t, axi_strb_t, axi_user_t)
  `AXI_TYPEDEF_B_CHAN_T (b_chan_t , axi_id_t  , axi_user_t)

  // PE Request Type - contains only the fields needed for VLSU
  typedef struct packed {
    riva_pkg::vid_t     reqId;        // Request ID for tracking and debugging
    logic [1:0]         mop;          // Memory operation mode (0: unit-stride, 1: strided, 2: indexed)
    riva_pkg::elen_t    baseAddr;     // Base address for the vector operation
    riscv_mv_pkg::vew_e sew;          // Element width encoding (00: 8b, 01: 16b, 10: 32b, 11: 64b)
    logic [4:0]         vd;           // Vector destination register index
    riva_pkg::elen_t    stride;       // Stride value for strided access mode
    vlen_t              vl;           // Vector length
    alen_t              al;           // Accumulator length
    riva_pkg::elen_t    vstart;       // Starting element index (for partial vector operations)
    logic               isLoad;       // 1: load operation, 0: store operation
    logic               vm;           // Vector mask enable (1: masked, 0: unmasked)
  } pe_req_t;

  // PE Response Type - minimal definition for VLSU
  typedef struct packed {
    logic [31:0]       dummy;        // Placeholder for future use
  } pe_resp_t;

// -----------------------------------------
// Type definitions (expanded from structs)
// -----------------------------------------
  // VLSU Request Interface - expanded from pe_req_t
  reg                       pe_req_valid;
  wire                      pe_req_ready;
  vid_t                     pe_req_bits_reqId;
  reg  [1:0]                pe_req_bits_mop;
  riva_pkg::elen_t          pe_req_bits_baseAddr;
  riscv_mv_pkg::vew_e       pe_req_bits_sew;
  reg  [4:0]                pe_req_bits_vd;
  riva_pkg::elen_t          pe_req_bits_stride;
  vlen_t                    pe_req_bits_vl;
  alen_t                    pe_req_bits_al;
  riva_pkg::elen_t          pe_req_bits_vstart;
  reg                       pe_req_bits_isLoad;
  reg                       pe_req_bits_vm;
  reg                       core_st_pending;

  // AXI Master Interface - expanded from axi_aw_t, axi_ar_t, axi_w_t, axi_r_t, axi_b_t
  // AXI AW Channel
  wire            m_axi_aw_valid;
  reg             m_axi_aw_ready;
  axi_id_t        m_axi_aw_bits_id;
  axi_addr_t      m_axi_aw_bits_addr;
  wire   [7:0]    m_axi_aw_bits_len;
  wire   [2:0]    m_axi_aw_bits_size;
  wire   [1:0]    m_axi_aw_bits_burst;
  wire            m_axi_aw_bits_lock;
  wire   [3:0]    m_axi_aw_bits_cache;
  wire   [2:0]    m_axi_aw_bits_prot;
  wire   [3:0]    m_axi_aw_bits_qos;
  wire   [3:0]    m_axi_aw_bits_region;
  axi_user_t      m_axi_aw_bits_user;

  // AXI AR Channel
  wire            m_axi_ar_valid;
  reg             m_axi_ar_ready;
  axi_id_t        m_axi_ar_bits_id;
  axi_addr_t      m_axi_ar_bits_addr;
  wire   [7:0]    m_axi_ar_bits_len;
  wire   [2:0]    m_axi_ar_bits_size;
  wire   [1:0]    m_axi_ar_bits_burst;
  wire            m_axi_ar_bits_lock;
  wire   [3:0]    m_axi_ar_bits_cache;
  wire   [2:0]    m_axi_ar_bits_prot;
  wire   [3:0]    m_axi_ar_bits_qos;
  wire   [3:0]    m_axi_ar_bits_region;
  axi_user_t      m_axi_ar_bits_user;

  // AXI W Channel
  wire            m_axi_w_valid;
  reg             m_axi_w_ready;
  axi_data_t      m_axi_w_bits_data;
  axi_strb_t      m_axi_w_bits_strb;
  wire            m_axi_w_bits_last;
  axi_user_t      m_axi_w_bits_user;

  // AXI R Channel
  reg             m_axi_r_valid;
  wire            m_axi_r_ready;
  axi_id_t        m_axi_r_bits_id;
  axi_data_t      m_axi_r_bits_data;
  reg   [1:0]     m_axi_r_bits_resp;
  reg             m_axi_r_bits_last;
  axi_user_t      m_axi_r_bits_user;

  // AXI B Channel
  reg             m_axi_b_valid;
  wire            m_axi_b_ready;
  axi_id_t        m_axi_b_bits_id;
  reg   [1:0]     m_axi_b_bits_resp;
  axi_user_t      m_axi_b_bits_user;

  // Lane Interface - Transmit lanes (VLSU to lanes)
  wire                        txs_0_valid;
  wire                        txs_1_valid;
  wire                        txs_2_valid;
  wire                        txs_3_valid;
  reg                         txs_0_ready;
  reg                         txs_1_ready;
  reg                         txs_2_ready;
  reg                         txs_3_ready;
  vid_t                       txs_0_bits_reqId;
  vid_t                       txs_1_bits_reqId;
  vid_t                       txs_2_bits_reqId;
  vid_t                       txs_3_bits_reqId;
  vaddr_set_t                 txs_0_bits_vaddr_set;
  vaddr_set_t                 txs_1_bits_vaddr_set;
  vaddr_set_t                 txs_2_bits_vaddr_set;
  vaddr_set_t                 txs_3_bits_vaddr_set;
  vaddr_bank_t                 txs_0_bits_vaddr_bank;
  vaddr_bank_t                 txs_1_bits_vaddr_bank;
  vaddr_bank_t                 txs_2_bits_vaddr_bank;
  vaddr_bank_t                 txs_3_bits_vaddr_bank;
  wire        [DLEN-1:0]      txs_0_bits_data;
  wire        [DLEN-1:0]      txs_1_bits_data;
  wire        [DLEN-1:0]      txs_2_bits_data;
  wire        [DLEN-1:0]      txs_3_bits_data;
  strb_t                      txs_0_bits_nbe;
  strb_t                      txs_1_bits_nbe;
  strb_t                      txs_2_bits_nbe;
  strb_t                      txs_3_bits_nbe;

  // Lane Interface - Receive lanes (lanes to VLSU)
  reg                         rxs_0_valid;
  reg                         rxs_1_valid;
  reg                         rxs_2_valid;
  reg                         rxs_3_valid;
  wire                        rxs_0_ready;
  wire                        rxs_1_ready;
  wire                        rxs_2_ready;
  wire                        rxs_3_ready;
  reg         [DLEN-1:0]      rxs_0_bits_data;
  reg         [DLEN-1:0]      rxs_1_bits_data;
  reg         [DLEN-1:0]      rxs_2_bits_data;
  reg         [DLEN-1:0]      rxs_3_bits_data;

  // Mask Interface
  reg                         mask_0_valid;
  reg                         mask_1_valid;
  reg                         mask_2_valid;
  reg                         mask_3_valid;
  strb_t                      mask_0_bits;
  strb_t                      mask_1_bits;
  strb_t                      mask_2_bits;
  strb_t                      mask_3_bits;
  wire                        load_mask_ready_o;
  wire                        store_mask_ready_o;

// -----------------------------------------
// reg initialize
// ----------------------------------------- 
  initial begin
    $display("[INFO] @%0t [%s:%d] hello from tb_top", $time, `__FILE__, `__LINE__);
    
    // VLSU Request Interface
    pe_req_valid             = 0;
    pe_req_bits_reqId        = 0;
    pe_req_bits_mop          = 0;
    pe_req_bits_baseAddr     = 0;
    pe_req_bits_sew          = riscv_mv_pkg::EW4;
    pe_req_bits_vd           = 0;
    pe_req_bits_stride       = 0;
    pe_req_bits_vl           = 0;
    pe_req_bits_al           = 0;
    pe_req_bits_vstart       = 0;
    pe_req_bits_isLoad       = 0;
    pe_req_bits_vm           = 0;
    core_st_pending          = 0;

    // AXI Interface
    m_axi_aw_ready           = 0;
    m_axi_ar_ready           = 0;
    m_axi_w_ready            = 0;
    m_axi_r_valid            = 0;
    m_axi_r_bits_id          = 0;
    m_axi_r_bits_data        = 0;
    m_axi_r_bits_resp        = 0;
    m_axi_r_bits_last        = 0;
    m_axi_r_bits_user        = 0;
    m_axi_b_valid            = 0;
    m_axi_b_bits_id          = 0;
    m_axi_b_bits_resp        = 0;
    m_axi_b_bits_user        = 0;

    // Lane Interface
    txs_0_ready              = 0;
    txs_1_ready              = 0;
    txs_2_ready              = 0;
    txs_3_ready              = 0;
    rxs_0_valid              = 0;
    rxs_1_valid              = 0;
    rxs_2_valid              = 0;
    rxs_3_valid              = 0;
    rxs_0_bits_data          = 0;
    rxs_1_bits_data          = 0;
    rxs_2_bits_data          = 0;
    rxs_3_bits_data          = 0;

    // Mask Interface
    mask_0_valid             = 0;
    mask_1_valid             = 0;
    mask_2_valid             = 0;
    mask_3_valid             = 0;
    mask_0_bits              = 0;
    mask_1_bits              = 0;
    mask_2_bits              = 0;
    mask_3_bits              = 0;
  end

// -----------------------------------------
// deal with clock, reset, cycles
// -----------------------------------------
  `ifndef SIM_VERILATOR
    reg             clock;
    reg             reset;
    
    initial begin
      clock      = 0;
      reset      = 0;
    end
    
    always #5 clock <= ~clock;
  `endif // SIM_VERILATOR
  
  reg [63:0] cycles;
  
  initial cycles = 0;
  
  always@(posedge clock) begin
    if (reset)
      cycles <= 0;
    else
      cycles <= cycles + 1;
  end

// -----------------------------------------
// VLSU module instantiate
// -----------------------------------------
  VLSU #(
    .NrLanes      (NrLanes      ),
    .VLEN         (VLEN         ),
    .ALEN         (ALEN         ),
    .pe_req_t     (pe_req_t     ),
    .pe_resp_t    (pe_resp_t    ),
    .AxiDataWidth (AxiDataWidth ),
    .AxiAddrWidth (AxiAddrWidth ),
    .AxiUserWidth (AxiUserWidth ),
    .axi_aw_t     (aw_chan_t    ),
    .axi_ar_t     (ar_chan_t    ),
    .axi_w_t      (w_chan_t     ),
    .axi_r_t      (r_chan_t     ),
    .axi_b_t      (b_chan_t     )
  ) u_VLSU (
    .clk_i                    (clock),
    .rst_ni                   (reset),
    
    // VLSU Request Interface
    .pe_req_valid_i           (pe_req_valid),
    .pe_req_ready_o           (pe_req_ready),
    .pe_req_i                 ('{reqId: pe_req_bits_reqId, mop: pe_req_bits_mop, baseAddr: pe_req_bits_baseAddr, 
                                  sew: pe_req_bits_sew, vd: pe_req_bits_vd, stride: pe_req_bits_stride, 
                                  vl: pe_req_bits_vl, al: pe_req_bits_al, vstart: pe_req_bits_vstart, isLoad: pe_req_bits_isLoad, vm: pe_req_bits_vm}),
    .core_st_pending_i        (core_st_pending),
    
    // AXI Master Interface
    .m_axi_aw_valid_o         (m_axi_aw_valid),
    .m_axi_aw_ready_i         (m_axi_aw_ready),
    .m_axi_aw_o               ('{m_axi_aw_bits_id, m_axi_aw_bits_addr, m_axi_aw_bits_len, m_axi_aw_bits_size, m_axi_aw_bits_burst, m_axi_aw_bits_lock, m_axi_aw_bits_cache, m_axi_aw_bits_prot, m_axi_aw_bits_qos, m_axi_aw_bits_region, m_axi_aw_bits_user}),

    .m_axi_w_valid_o          (m_axi_w_valid),
    .m_axi_w_ready_i          (m_axi_w_ready),
    .m_axi_w_o                ('{m_axi_w_bits_data, m_axi_w_bits_strb, m_axi_w_bits_last, m_axi_w_bits_user}),

    .m_axi_b_valid_i          (m_axi_b_valid),
    .m_axi_b_ready_o          (m_axi_b_ready),
    .m_axi_b_i                ('{id: m_axi_b_bits_id, resp: m_axi_b_bits_resp, user: m_axi_b_bits_user}),

    .m_axi_ar_valid_o         (m_axi_ar_valid),
    .m_axi_ar_ready_i         (m_axi_ar_ready),
    .m_axi_ar_o               ('{m_axi_ar_bits_id, m_axi_ar_bits_addr, m_axi_ar_bits_len, m_axi_ar_bits_size, m_axi_ar_bits_burst, m_axi_ar_bits_lock, m_axi_ar_bits_cache, m_axi_ar_bits_prot, m_axi_ar_bits_qos, m_axi_ar_bits_region, m_axi_ar_bits_user}),
    
    .m_axi_r_valid_i          (m_axi_r_valid),
    .m_axi_r_ready_o          (m_axi_r_ready),
    .m_axi_r_i                ('{id: m_axi_r_bits_id, data: m_axi_r_bits_data, resp: m_axi_r_bits_resp, last: m_axi_r_bits_last, user: m_axi_r_bits_user}),

    // Lane Interface - Transmit lanes
    .txs_valid_o              ({txs_3_valid, txs_2_valid, txs_1_valid, txs_0_valid}),
    .txs_ready_i              ({txs_3_ready, txs_2_ready, txs_1_ready, txs_0_ready}),
    .txs_reqId_o             ({txs_3_bits_reqId, txs_2_bits_reqId, txs_1_bits_reqId, txs_0_bits_reqId}),
    .txs_vaddr_set_o          ({txs_3_bits_vaddr_set, txs_2_bits_vaddr_set, txs_1_bits_vaddr_set, txs_0_bits_vaddr_set}),
    .txs_vaddr_bank_o          ({txs_3_bits_vaddr_bank, txs_2_bits_vaddr_bank, txs_1_bits_vaddr_bank, txs_0_bits_vaddr_bank}),
    .txs_data_o               ({txs_3_bits_data, txs_2_bits_data, txs_1_bits_data, txs_0_bits_data}),
    .txs_nbe_o                ({txs_3_bits_nbe, txs_2_bits_nbe, txs_1_bits_nbe, txs_0_bits_nbe}),
    
    // Lane Interface - Receive lanes
    .rxs_valid_i              ({rxs_3_valid, rxs_2_valid, rxs_1_valid, rxs_0_valid}),
    .rxs_ready_o              ({rxs_3_ready, rxs_2_ready, rxs_1_ready, rxs_0_ready}),
    .rxs_data_i               ({rxs_3_bits_data, rxs_2_bits_data, rxs_1_bits_data, rxs_0_bits_data}),

    // Mask Interface
    .mask_valid_i             ({mask_3_valid, mask_2_valid, mask_1_valid, mask_0_valid}),
    .mask_bits_i              ({mask_3_bits, mask_2_bits, mask_1_bits, mask_0_bits}),
    .load_mask_ready_o        (load_mask_ready_o),
    .store_mask_ready_o       (store_mask_ready_o)
  );


// -----------------------------------------
// tracing command interface
// -----------------------------------------
  `ifndef SIM_VERILATOR
    initial begin
      string dump_file = "dump";
      integer dump_start_cycle = 0;
            
      if ($test$plusargs("dump_enable=1")) begin
        // 1. set dump file name
        if ($value$plusargs("dump_file=%s", dump_file))
          $display("[INFO] @%0t [%s:%d] dump_file => %s ", $time, `__FILE__, `__LINE__, dump_file);
        else
          $display("[INFO] @%0t [%s:%d] [default] dump_file => %s ", $time, `__FILE__, `__LINE__, dump_file);
        
        // 2. set dump start cycle
        if ($value$plusargs("dump_start_cycle=%d", dump_start_cycle))
          $display("[INFO] @%0t [%s:%d] dump_start_cycle: %d ", $time, `__FILE__, `__LINE__, dump_start_cycle);
      
        // 3. set dump type
        if ($test$plusargs("dump_vcd")) begin
          $display("[INFO] @%0t [%s:%d] enable dump_vcd ", $time, `__FILE__, `__LINE__);
  
          repeat(dump_start_cycle) @(posedge clock);
          $display("[INFO] @%0t [%s:%d] start dump_vcd at cycle => %d... ", $time, `__FILE__, `__LINE__, dump_start_cycle);
  
          $dumpfile({dump_file, ".vcd"});
          $dumpvars(0, tb_top);
        end else if ($test$plusargs("dump_fsdb")) begin
          $display("[INFO] @%0t [%s:%d] enable dump_fsdb ", $time, `__FILE__, `__LINE__);
          
          repeat(dump_start_cycle) @(posedge clock);
          `ifdef SIM_VCS
            $display("[INFO] @%0t [%s:%d] start dump_fsdb at cycle => %d... ", $time, `__FILE__, `__LINE__, dump_start_cycle);
            $fsdbDumpfile({dump_file, ".fsdb"});
            $fsdbDumpvars(0, tb_top, "+all");
          `else
            $display("[ERROR] @%0t [%s:%d] SIM_VCS is not defined!... ", $time, `__FILE__, `__LINE__);
            $fatal;
          `endif
        end else begin
          $display("[ERROR] @%0t [%s:%d] neither dump_vcd or dump_fsdb are not pass in", $time, `__FILE__, `__LINE__);
          $fatal;
        end
      end
    end
  `endif

// -----------------------------------------
// shutdown logic
// -----------------------------------------
  initial begin
    integer shutdown_cycles = 0;
    
    if ($test$plusargs("enable_shutdown")) begin
    
      if ($value$plusargs("shutdown_cycles=%d", shutdown_cycles)) begin
        $display("shutdown_cycles: %d", shutdown_cycles);
      end
    
      repeat(shutdown_cycles) @(posedge clock);
    
      $finish;
    end
  end

// -----------------------------------------
// user custom code
// -----------------------------------------

endmodule // tb_top 